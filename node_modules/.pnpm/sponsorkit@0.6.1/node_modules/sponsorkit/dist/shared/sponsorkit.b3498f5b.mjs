import { loadConfig as loadConfig$1 } from 'unconfig';
import dotenv from 'dotenv';
import { $fetch } from 'ohmyfetch';
import { parse } from 'node-html-parser';
import imageDataURI from 'image-data-uri';
import sharp from 'sharp';

function genSvgImage(x, y, size, url) {
  return `<image x="${x}" y="${y}" width="${size}" height="${size}" xlink:href="${url}"/>`;
}
function generateBadge(x, y, sponsor, preset) {
  const size = preset.avatar.size;
  const { login } = sponsor;
  let name = (sponsor.name || sponsor.login).trim();
  const url = sponsor.linkUrl || sponsor.login ? `https://github.com/${sponsor.login}` : void 0;
  if (preset.name && preset.name.maxLength && name.length > preset.name.maxLength) {
    if (name.includes(" "))
      name = name.split(" ")[0];
    else
      name = `${name.slice(0, preset.name.maxLength - 3)}...`;
  }
  const avatarUrl = (size < 50 ? sponsor.avatarUrlLowRes : size < 90 ? sponsor.avatarUrlMediumRes : sponsor.avatarUrlHighRes) || sponsor.avatarUrl;
  return `
<a ${url ? `xlink:href="${url}"` : ""} class="${preset.classes || "sponsorkit-link"}" target="_blank" id="${login}">
  ${preset.name ? `<text x="${x + size / 2}" y="${y + size + 18}" text-anchor="middle" class="${preset.name.classes || "sponsorkit-name"}" fill="${preset.name.color || "currentColor"}">${encodeHtmlEntities(name)}</text>` : ""}
  ${genSvgImage(x, y, size, avatarUrl)}
</a>`.trim();
}
class SvgComposer {
  constructor(config) {
    this.config = config;
    this.height = 0;
    this.body = "";
  }
  addSpan(height = 0) {
    this.height += height;
    return this;
  }
  addTitle(text, classes = "sponsorkit-tier-title") {
    return this.addText(text, classes);
  }
  addText(text, classes = "text") {
    this.body += `<text x="${this.config.width / 2}" y="${this.height}" text-anchor="middle" class="${classes}">${text}</text>`;
    this.height += 20;
    return this;
  }
  addRaw(svg) {
    this.body += svg;
    return this;
  }
  addSponsorLine(sponsors, preset) {
    const offsetX = (this.config.width - sponsors.length * preset.boxWidth) / 2 + (preset.boxWidth - preset.avatar.size) / 2;
    this.body += sponsors.map((s, i) => {
      const x = offsetX + preset.boxWidth * i;
      const y = this.height;
      return generateBadge(x, y, s.sponsor, preset);
    }).join("\n");
    this.height += preset.boxHeight;
  }
  addSponsorGrid(sponsors, preset) {
    const perLine = Math.floor((this.config.width - (preset.container?.sidePadding || 0) * 2) / preset.boxWidth);
    new Array(Math.ceil(sponsors.length / perLine)).fill(0).forEach((_, i) => {
      this.addSponsorLine(sponsors.slice(i * perLine, (i + 1) * perLine), preset);
    });
    return this;
  }
  generateSvg() {
    return `
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 ${this.config.width} ${this.height}" width="${this.config.width}" height="${this.height}">
<!-- Generated by https://github.com/antfu/sponsorskit -->
<style>${this.config.svgInlineCSS}</style>
${this.body}
</svg>
`;
  }
}
function encodeHtmlEntities(str) {
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

async function resolveAvatars(ships, fallbackAvatar) {
  return Promise.all(ships.map(async (ship) => {
    const data = await $fetch(ship.sponsor.avatarUrl, { responseType: "arrayBuffer" }).catch((e) => {
      if (typeof fallbackAvatar === "string")
        return $fetch(fallbackAvatar, { responseType: "arrayBuffer" });
      if (fallbackAvatar)
        return fallbackAvatar;
      throw e;
    });
    const radius = ship.sponsor.type === "User" ? 0.5 : 0.15;
    ship.sponsor.avatarUrlHighRes = await imageDataURI.encode(await round(data, radius, 120), "PNG");
    ship.sponsor.avatarUrlMediumRes = await imageDataURI.encode(await round(data, radius, 80), "PNG");
    ship.sponsor.avatarUrlLowRes = await imageDataURI.encode(await round(data, radius, 50), "PNG");
  }));
}
function toBuffer(ab) {
  const buf = Buffer.alloc(ab.byteLength);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buf.length; ++i)
    buf[i] = view[i];
  return buf;
}
async function round(image, radius = 0.5, size = 100) {
  const rect = Buffer.from(
    `<svg><rect x="0" y="0" width="${size}" height="${size}" rx="${size * radius}" ry="${size * radius}"/></svg>`
  );
  return await sharp(typeof image === "string" ? image : toBuffer(image)).resize(size, size, { fit: sharp.fit.cover }).composite([{
    blend: "dest-in",
    input: rect,
    density: 72
  }]).png({ quality: 80, compressionLevel: 8 }).toBuffer();
}
function svgToPng(svg) {
  return sharp(Buffer.from(svg), { density: 150 }).png({ quality: 90 }).toBuffer();
}

function getDeprecatedEnv(name, replacement) {
  const value = process.env[name];
  if (value)
    console.warn(`[sponsorkit] env.${name} is deprecated, use env.${replacement} instead`);
  return value;
}
function loadEnv() {
  dotenv.config();
  const config = {
    github: {
      login: process.env.SPONSORKIT_GITHUB_LOGIN || process.env.GITHUB_LOGIN || getDeprecatedEnv("SPONSORKIT_LOGIN", "SPONSORKIT_GITHUB_LOGIN"),
      token: process.env.SPONSORKIT_GITHUB_TOKEN || process.env.GITHUB_TOKEN || getDeprecatedEnv("SPONSORKIT_TOKEN", "SPONSORKIT_GITHUB_TOKEN"),
      type: process.env.SPONSORKIT_GITHUB_TYPE
    },
    patreon: {
      token: process.env.SPONSORKIT_PATREON_TOKEN
    },
    opencollective: {
      key: process.env.SPONSORKIT_OPENCOLLECTIVE_KEY || process.env.OPENCOLLECTIVE_KEY,
      id: process.env.SPONSORKIT_OPENCOLLECTIVE_ID || process.env.OPENCOLLECTIVE_ID,
      slug: process.env.SPONSORKIT_OPENCOLLECTIVE_SLUG || process.env.OPENCOLLECTIVE_SLUG,
      githubHandle: process.env.SPONSORKIT_OPENCOLLECTIVE_GH_HANDLE || process.env.OPENCOLLECTIVE_GH_HANDLE
    },
    outputDir: process.env.SPONSORKIT_DIR
  };
  return JSON.parse(JSON.stringify(config));
}

const fallback = `
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 135.47 135.47">
    <path fill="#2d333b" stroke="#000" stroke-linejoin="round" stroke-width=".32" d="M.16.16h135.15v135.15H.16z" paint-order="stroke markers fill"/>
    <path fill="#636e7b" fill-rule="evenodd" d="M81.85 53.56a14.13 14.13 0 1 1-28.25 0 14.13 14.13 0 0 1 28.25 0zm.35 17.36a22.6 22.6 0 1 0-28.95 0 33.92 33.92 0 0 0-19.38 29.05 4.24 4.24 0 0 0 8.46.4 25.43 25.43 0 0 1 50.8 0 4.24 4.24 0 1 0 8.46-.4 33.93 33.93 0 0 0-19.4-29.05z"/>
</svg>
`;
const FALLBACK_AVATAR = svgToPng(fallback);

const none = {
  avatar: {
    size: 0
  },
  boxWidth: 0,
  boxHeight: 0,
  container: {
    sidePadding: 0
  }
};
const base = {
  avatar: {
    size: 40
  },
  boxWidth: 48,
  boxHeight: 48,
  container: {
    sidePadding: 30
  }
};
const xs = {
  avatar: {
    size: 25
  },
  boxWidth: 30,
  boxHeight: 30,
  container: {
    sidePadding: 30
  }
};
const small = {
  avatar: {
    size: 35
  },
  boxWidth: 38,
  boxHeight: 38,
  container: {
    sidePadding: 30
  }
};
const medium = {
  avatar: {
    size: 50
  },
  boxWidth: 80,
  boxHeight: 90,
  container: {
    sidePadding: 20
  },
  name: {
    maxLength: 10
  }
};
const large = {
  avatar: {
    size: 70
  },
  boxWidth: 95,
  boxHeight: 115,
  container: {
    sidePadding: 20
  },
  name: {
    maxLength: 16
  }
};
const xl = {
  avatar: {
    size: 90
  },
  boxWidth: 120,
  boxHeight: 130,
  container: {
    sidePadding: 20
  },
  name: {
    maxLength: 20
  }
};
const presets = {
  none,
  xs,
  small,
  base,
  medium,
  large,
  xl
};

const defaultTiers = [
  {
    title: "Past Sponsors",
    monthlyDollars: -1,
    preset: presets.xs
  },
  {
    title: "Backers",
    preset: presets.base
  },
  {
    title: "Sponsors",
    monthlyDollars: 10,
    preset: presets.medium
  },
  {
    title: "Silver Sponsors",
    monthlyDollars: 50,
    preset: presets.large
  },
  {
    title: "Gold Sponsors",
    monthlyDollars: 100,
    preset: presets.xl
  }
];
const defaultInlineCSS = `
text {
  font-weight: 300;
  font-size: 14px;
  fill: #777777;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}
.sponsorkit-link {
  cursor: pointer;
}
.sponsorkit-tier-title {
  font-weight: 500;
  font-size: 20px;
}
`;
const defaultConfig = {
  width: 800,
  outputDir: "./sponsorkit",
  cacheFile: ".cache.json",
  formats: ["json", "svg", "png"],
  tiers: defaultTiers,
  name: "sponsors",
  includePrivate: false,
  svgInlineCSS: defaultInlineCSS
};
function defineConfig(config) {
  return config;
}
async function loadConfig(inlineConfig = {}) {
  const env = loadEnv();
  const { config = {} } = await loadConfig$1({
    sources: [
      {
        files: "sponsor.config"
      },
      {
        files: "sponsorkit.config"
      }
    ],
    merge: true
  });
  const hasNegativeTier = !!config.tiers?.find((tier) => tier && tier.monthlyDollars <= 0);
  const resolved = {
    fallbackAvatar: FALLBACK_AVATAR,
    includePastSponsors: hasNegativeTier,
    ...defaultConfig,
    ...env,
    ...config,
    ...inlineConfig,
    github: {
      ...env.github,
      ...config.github,
      ...inlineConfig.github
    },
    patreon: {
      ...env.patreon,
      ...config.patreon,
      ...inlineConfig.patreon
    },
    opencollective: {
      ...env.opencollective,
      ...config.opencollective,
      ...inlineConfig.opencollective
    }
  };
  return resolved;
}

function pickSponsorsInfo(html) {
  const root = parse(html);
  const baseDate = new Date();
  const sponsors = root.querySelectorAll("div").map((el, index) => {
    const isPublic = el.querySelector("img");
    const createdAt = new Date(baseDate.getTime() - index * 1e3 * 60 * 60 * 24 * 30).toUTCString();
    const name = isPublic ? isPublic?.getAttribute("alt")?.replace("@", "") : "Private Sponsor";
    const avatarUrl = isPublic ? isPublic?.getAttribute("src") : FALLBACK_AVATAR;
    const login = isPublic ? el.querySelector("a")?.getAttribute("href")?.replace("/", "") : void 0;
    const type = el.querySelector("a")?.getAttribute("data-hovercard-type")?.replace(/^\S/, (s) => s.toUpperCase());
    return {
      sponsor: {
        __typename: void 0,
        login,
        name,
        avatarUrl,
        type
      },
      isOneTime: void 0,
      monthlyDollars: -1,
      privacyLevel: isPublic ? "PUBLIC" : "PRIVATE",
      tierName: void 0,
      createdAt
    };
  });
  return sponsors;
}
async function getPastSponsors(username) {
  const allSponsors = [];
  let newSponsors = [];
  let cursor = 1;
  do {
    const content = await $fetch(`https://github.com/sponsors/${username}/sponsors_partial?filter=inactive&page=${cursor++}`, { method: "GET" });
    newSponsors = pickSponsorsInfo(content);
    allSponsors.push(...newSponsors);
  } while (newSponsors.length);
  return allSponsors;
}

const API$1 = "https://api.github.com/graphql";
const graphql$1 = String.raw;
const GitHubProvider = {
  name: "github",
  fetchSponsors(config) {
    return fetchGitHubSponsors(
      config.github?.token || config.token,
      config.github?.login || config.login,
      config.github?.type || "user",
      config
    );
  }
};
async function fetchGitHubSponsors(token, login, type, config) {
  if (!token)
    throw new Error("GitHub token is required");
  if (!login)
    throw new Error("GitHub login is required");
  if (!["user", "organization"].includes(type))
    throw new Error("GitHub type must be either `user` or `organization`");
  const sponsors = [];
  let cursor;
  do {
    const query = makeQuery$1(login, type, cursor);
    const data = await $fetch(API$1, {
      method: "POST",
      body: { query },
      headers: {
        "Authorization": `bearer ${token}`,
        "Content-Type": "application/json"
      }
    });
    if (!data)
      throw new Error(`Get no response on requesting ${API$1}`);
    else if (data.errors?.[0]?.type === "INSUFFICIENT_SCOPES")
      throw new Error("Token is missing the `read:user` and/or `read:org` scopes");
    else if (data.errors?.length)
      throw new Error(`GitHub API error:
${JSON.stringify(data.errors, null, 2)}`);
    sponsors.push(
      ...data.data[type].sponsorshipsAsMaintainer.nodes || []
    );
    if (data.data[type].sponsorshipsAsMaintainer.pageInfo.hasNextPage)
      cursor = data.data[type].sponsorshipsAsMaintainer.pageInfo.endCursor;
    else
      cursor = void 0;
  } while (cursor);
  const processed = sponsors.map((raw) => ({
    sponsor: {
      ...raw.sponsorEntity,
      __typename: void 0,
      type: raw.sponsorEntity.__typename
    },
    isOneTime: raw.tier.isOneTime,
    monthlyDollars: raw.tier.monthlyPriceInDollars,
    privacyLevel: raw.privacyLevel,
    tierName: raw.tier.name,
    createdAt: raw.createdAt
  }));
  if (config.includePastSponsors) {
    try {
      processed.push(...await getPastSponsors(login));
    } catch (e) {
      console.error("Failed to fetch past sponsors:", e);
    }
  }
  return processed;
}
function makeQuery$1(login, type, cursor) {
  return graphql$1`{
  ${type}(login: "${login}") {
    sponsorshipsAsMaintainer(first: 100${cursor ? ` after: "${cursor}"` : ""}) {
      totalCount
      pageInfo {
        endCursor
        hasNextPage
      }
      nodes {
        createdAt
        privacyLevel
        tier {
          name
          isOneTime
          monthlyPriceInCents
          monthlyPriceInDollars
        }
        sponsorEntity {
          __typename
          ...on Organization {
            login
            name
            avatarUrl
          }
          ...on User {
            login
            name
            avatarUrl
          }
        }
      }
    }
  }
}`;
}

const PatreonProvider = {
  name: "patreon",
  fetchSponsors(config) {
    return fetchPatreonSponsors(config.patreon?.token || config.token);
  }
};
async function fetchPatreonSponsors(token) {
  if (!token)
    throw new Error("Patreon token is required");
  const userData = await $fetch(
    "https://www.patreon.com/api/oauth2/api/current_user/campaigns?include=null",
    {
      method: "GET",
      headers: {
        "Authorization": `bearer ${token}`,
        "Content-Type": "application/json"
      },
      responseType: "json"
    }
  );
  const userCampaignId = userData.data[0].id;
  const sponsors = [];
  let sponsorshipApi = `https://www.patreon.com/api/oauth2/api/campaigns/${userCampaignId}/pledges?include=patron.null,reward.null&page%5Bcount%5D=100`;
  do {
    const sponsorshipData = await $fetch(sponsorshipApi, {
      method: "GET",
      headers: {
        "Authorization": `bearer ${token}`,
        "Content-Type": "application/json"
      },
      responseType: "json"
    });
    sponsors.push(
      ...sponsorshipData.data.filter((pledge) => !!pledge.relationships?.reward?.data).filter((pledge) => {
        if (pledge.attributes.declined_since)
          return new Date(pledge.attributes.declined_since).getTime() - new Date().getTime() > 0;
        return true;
      }).map((pledge) => ({
        pledge,
        patron: sponsorshipData.included.find(
          (v) => v.id === pledge.relationships.patron.data.id
        ),
        reward: sponsorshipData.included.find(
          (v) => v.id === pledge.relationships.reward.data.id
        )
      }))
    );
    sponsorshipApi = sponsorshipData.links.next;
  } while (sponsorshipApi);
  const processed = sponsors.map(
    (raw) => ({
      sponsor: {
        avatarUrl: raw.patron.attributes.image_url,
        login: raw.patron.attributes.first_name,
        name: raw.patron.attributes.full_name,
        type: "User",
        linkUrl: raw.patron.attributes.url
      },
      isOneTime: false,
      monthlyDollars: Math.floor(raw.pledge.attributes.amount_cents / 100),
      privacyLevel: "PUBLIC",
      tierName: raw.reward.attributes.title,
      createdAt: raw.pledge.attributes.created_at
    })
  );
  return processed;
}

const API = "https://api.opencollective.com/graphql/v2/";
const graphql = String.raw;
const OpenCollectiveProvider = {
  name: "opencollective",
  fetchSponsors(config) {
    return fetchOpenCollectiveSponsors(
      config.opencollective?.key,
      config.opencollective?.id,
      config.opencollective?.slug,
      config.opencollective?.githubHandle
    );
  }
};
async function fetchOpenCollectiveSponsors(key, id, slug, githubHandle) {
  if (!key)
    throw new Error("OpenCollective api key is required");
  if (!slug && !id && !githubHandle)
    throw new Error("OpenCollective collective id or slug or GitHub handle is required");
  const sponsors = [];
  let offset;
  offset = 0;
  do {
    const query = makeQuery(id, slug, githubHandle, offset);
    const data = await $fetch(API, {
      method: "POST",
      body: { query },
      headers: {
        "Api-Key": `${key}`,
        "Content-Type": "application/json"
      }
    });
    sponsors.push(
      ...data.data.collective?.members.nodes || []
    );
    if (data.data.collective?.members.nodes.length !== 0)
      offset += data.data.collective?.members.nodes.length;
    else
      offset = void 0;
  } while (offset);
  const processed = sponsors.map((raw) => ({
    sponsor: {
      type: raw.account.type === "INDIVIDUAL" ? "User" : "Organization",
      login: raw.account.slug,
      name: raw.account.name,
      avatarUrl: raw.account.imageUrl,
      linkUrl: `https://opencollective.com/${raw.account.slug}`
    },
    isOneTime: !raw.tier || raw.tier.type === "DONATION",
    monthlyDollars: raw.totalDonations.value,
    privacyLevel: !raw.tier || raw.account.isIncognito ? "PRIVATE" : "PUBLIC",
    tierName: !raw.tier ? "" : raw.tier.name,
    createdAt: raw.createdAt
  }));
  return processed;
}
function makeQuery(id, slug, githubHandle, offset) {
  return graphql`{
  collective(${id ? `id: "${id}", ` : ""}${slug ? `slug: "${slug}", ` : ""}${githubHandle ? `githubHandle: "${githubHandle}", ` : ""}, throwIfMissing: true) {
    members(limit: 100${offset ? ` offset: ${offset}` : ""} role: [BACKER]) {
      offset
      limit
      totalCount
      nodes {
        id
        role
        createdAt
        totalDonations {
          value
          currency
          valueInCents
        }
        tier {
          name
          type
        }
        account {
          name
          slug
          type
          isIncognito
          imageUrl(height: 460, format: png)
        }
      }
    }
  }
}`;
}

const ProvidersMap = {
  github: GitHubProvider,
  patreon: PatreonProvider,
  opencollective: OpenCollectiveProvider
};
function guessProviders(config) {
  const items = [];
  if (config.github && config.github.login)
    items.push("github");
  if (config.patreon && config.patreon.token)
    items.push("patreon");
  if (config.opencollective && (config.opencollective.id || config.opencollective.slug || config.opencollective.githubHandle))
    items.push("opencollective");
  if (!items.length)
    items.push("github");
  return items;
}
function resolveProviders(names) {
  return Array.from(new Set(names)).map((i) => {
    if (typeof i === "string") {
      const provider = ProvidersMap[i];
      if (!provider)
        throw new Error(`Unknown provider: ${i}`);
      return provider;
    }
    return i;
  });
}

export { GitHubProvider as G, ProvidersMap as P, SvgComposer as S, generateBadge as a, round as b, defaultInlineCSS as c, defaultTiers as d, defaultConfig as e, defineConfig as f, genSvgImage as g, guessProviders as h, resolveProviders as i, fetchGitHubSponsors as j, loadConfig as l, makeQuery$1 as m, presets as p, resolveAvatars as r, svgToPng as s };
